import numpy as np
import os

from scipy.constants import mu_0 as mu0


def get_scale(unit):
    """
    Returns the scaling factor corresponding to the provided unit.

    Parameters
    ----------
    unit : str
        The unit for which the scaling factor is requested.
        Accepted values are:
        - '[mm]' : millimeters
        - '[V/m]' : volts per meter
        - '[A/m]' : amperes per meter

    Returns
    -------
    float
        The scaling factor corresponding to the unit.
        - 1e-3 for millimeters ('[mm]')
        - 1 for volts per meter ('[V/m]')
        - mu0 (vacuum permeability) for amperes per meter ('[A/m]')
    """

    if unit == "[mm]":
        return 1e-3
    elif unit == "[V/m]":
        return 1
    elif unit == "[A/m]":
        return mu0


def get_vec(x):
    """
    Processes the input list or array `x` to compute key vector parameters.

    The function computes the minimum and maximum values of `x`, the difference
    between consecutive unique and sorted elements (`dx`), and the number of
    unique elements in `x`.

    Parameters
    ----------
    x : array-like
        A list or NumPy array of numerical values from which to compute the vector parameters.

    Returns
    -------
    xmin : float
        The minimum value in `x`.
    xmax : float
        The maximum value in `x`.
    dx : float
        The uniform difference between consecutive unique elements in `x`.
        Raises an assertion error if differences are not uniform.
    nx : int
        The number of unique elements in `x`.
    """

    sx = set(x)
    nx = len(sx)
    xlist = np.array(sorted(list(sx)))
    dx = np.diff(xlist)
    assert np.allclose(dx, dx[0])
    dx = dx[0]
    return min(x), max(x), dx, nx


def read_cst_ascii_3d_field(filePath, n_header=2):
    """
    Parses a 3D field file generated by CST, extracting field data and header information.

    The function reads and processes an ASCII file containing 3D electromagnetic field data
    (E or H fields) in the form of vectors (x, y, z) followed by field components. The field data
    can be either static or time-varying (complex fields) depending on the format.

    Parameters
    ----------
    filePath : str
        The full path to the 3D field ASCII file.
    n_header : int, optional
        The number of header lines to skip before reading the field data. Default is 2.

    Returns
    -------
    data : numpy.ndarray
        A NumPy array containing the parsed 3D field data. The format of the data depends on
        whether the field is static or time-varying. The array is ordered in Fortran ('F') format.

    header_info : dict
        A dictionary containing extracted information from the file header, such as units and
        field types (E or H field components).

    Notes
    -----
    The header structure for static fields is expected to follow:

    - x [units], y [units], z [units], Fx [units], Fy [units], Fz [units]
    - Example:
        ```
        x [mm]    y [mm]    z [mm]    Ex [V/m]    Ey [V/m]    Ez [V/m]
        --------------------------------------------------------------
        ```

    For time-varying or complex fields, the header structure includes both real and imaginary
    components for the field, such as:

    - FxRe [units], FyRe [units], FzRe [units], FxIm [units], FyIm [units], FzIm [units]
    - Example:
        ```
        x [mm]    y [mm]    z [mm]    ExRe [V/m]    EyRe [V/m]    EzRe [V/m]    ExIm [V/m]    EyIm [V/m]    EzIm [V/m]
        ----------------------------------------------------------------------------------------------------------------
        ```

    The data in the file is assumed to be ordered in Fortran ('F') format, meaning column-major order.

    """

    with open(filePath, "r") as fid:
        header = fid.readline()

    headers = header.split()

    columns, units = headers[::2], headers[1::2]

    # print(columns, units)

    field_columns = list(
        set([c[:2] for c in columns if c.startswith("E") or c.startswith("H")])
    )

    if all([f.startswith("E") for f in field_columns]):
        field_type = "electric"
    elif all([f.startswith("H") for f in field_columns]):
        field_type = "magnetic"
    else:
        raise ValueError("Mixed CST mode not curretly supported.")

    dat = np.loadtxt(filePath, skiprows=n_header)

    X = dat[:, 0] * get_scale(units[0])
    Y = dat[:, 1] * get_scale(units[1])
    Z = dat[:, 2] * get_scale(units[2])

    xmin, xmax, dx, nx = get_vec(X)
    ymin, ymax, dy, ny = get_vec(Y)
    zmin, zmax, dz, nz = get_vec(Z)

    shape = (nx, ny, nz)

    # Check if the field is complex:
    if len(columns) == 9:
        # - sign to convert to exp(-i omega t)
        Fx = (dat[:, 3] - 1j * dat[:, 4]).reshape(shape, order="F") * get_scale(
            units[3]
        )
        Fy = (dat[:, 5] - 1j * dat[:, 6]).reshape(shape, order="F") * get_scale(
            units[4]
        )
        Fz = (dat[:, 7] - 1j * dat[:, 8]).reshape(shape, order="F") * get_scale(
            units[5]
        )

    elif len(columns) == 6:
        Fx = dat[:, 3].reshape(shape, order="F") * get_scale(units[3])
        Fy = dat[:, 4].reshape(shape, order="F") * get_scale(units[4])
        Fz = dat[:, 5].reshape(shape, order="F") * get_scale(units[5])

    attrs = {}
    attrs["gridOriginOffset"] = (xmin, ymin, zmin)
    attrs["gridSpacing"] = (dx, dy, dz)
    attrs["gridSize"] = (nx, ny, nz)

    components = {
        f"{field_type}Field/x": Fx,
        f"{field_type}Field/y": Fy,
        f"{field_type}Field/z": Fz,
    }

    return attrs, components


def read_cst_ascii_3d_static_field(ffile):
    """
    Parses a complete 3D static real electric or magnetic field from a corresponding CST E or H ASCII file.

    This function reads and processes static (real) electric (E) or magnetic (H) field data from a CST-generated
    ASCII file. The file contains 3D spatial field components (Ex, Ey, Ez for E-field or Hx, Hy, Hz for H-field)
    at each point in the grid.

    Parameters
    ----------
    ffile : str
        Path to the ASCII file containing the real static field data (E-field or H-field) generated by CST.

    Returns
    -------
    data : dict
        FieldMesh ready data dict for the static field.
    """

    attrs, components = read_cst_ascii_3d_field(ffile)

    attrs["eleAnchorPt"] = "center"
    attrs["gridGeometry"] = "rectangular"
    attrs["axisLabels"] = ("x", "y", "z")
    attrs["gridLowerBound"] = (0, 0, 0)
    attrs["harmonic"] = 0
    attrs["fundamentalFrequency"] = 0

    data = dict(attrs=attrs, components=components)

    return data


def read_cst_ascii_3d_complex_fields(efile, hfile, frequency, harmonic=1):
    """
    Parses a complete 3D field map from corresponding CST E and H field files for a complex electromagnetic mode.

    This function reads and processes both the electric (E) and magnetic (H) field data from separate ASCII files
    generated by CST, and associates them with the specified frequency and harmonic of the electromagnetic mode.

    Parameters
    ----------
    efile : str
        Path to the electric field (E-field) file containing the full complex electromagnetic mode.

    hfile : str
        Path to the magnetic field (H-field) file containing the full complex electromagnetic mode.

    frequency : float
        The frequency of the electromagnetic mode in Hz.

    harmonic : int, optional
        The mode harmonic to be considered. The default is 1 (fundamental harmonic).

    Returns
    ----------
    data : dict
        FieldMesh style data dict containing the complex fields
    """

    assert os.path.exists(efile), "Could not find electric field file"
    assert os.path.exists(hfile), "Could not find magnetic field file"

    e_attrs, e_components = read_cst_ascii_3d_field(efile)
    b_attrs, b_components = read_cst_ascii_3d_field(hfile)

    assert e_attrs["gridOriginOffset"] == b_attrs["gridOriginOffset"]
    assert e_attrs["gridSpacing"] == b_attrs["gridSpacing"]
    assert e_attrs["gridSize"] == b_attrs["gridSize"]

    components = {**e_components, **b_components}

    attrs = e_attrs
    attrs["eleAnchorPt"] = "center"
    attrs["gridGeometry"] = "rectangular"
    attrs["axisLabels"] = ("x", "y", "z")
    attrs["gridLowerBound"] = (0, 0, 0)
    attrs["harmonic"] = harmonic
    attrs["fundamentalFrequency"] = frequency

    data = dict(attrs=attrs, components=components)

    return data
