from scipy.constants import mu_0 as u0
from scipy.constants import pi

from matplotlib import pyplot as plt
import numpy as np

from pmd_beamphysics import FieldMesh

def set_axes_equal(ax):

    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    
    # Find the max range for all axes
    max_range = np.abs(limits[:, 1] - limits[:, 0]).max() / 2.0
    
    # Calculate midpoints for all axes
    mid_x = np.mean(limits[0])
    mid_y = np.mean(limits[1])
    mid_z = np.mean(limits[2])
    
    # Set limits to be centered and equal in range
    ax.set_xlim(mid_x - max_range, mid_x + max_range)
    ax.set_ylim(mid_y - max_range, mid_y + max_range)
    ax.set_zlim(mid_z - max_range, mid_z + max_range)

def plot_3d_vector(v, 
                   origin=np.array([0,0,0]), 
                   plot_arrow=True,
                   plot_line=False,
                   ax=None, 
                   color='b', 
                   elev=45, 
                   azim=-45):

    # Create a new figure and 3D axes if none are provided
    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        
    if plot_arrow and not plot_line:
        
        # Plot the vector as an arrow
        ax.quiver(
            origin[0], origin[1], origin[2],  # Starting point of the vector
            v[0], v[1], v[2],  # Vector components (dx, dy, dz)
            arrow_length_ratio=0.2,  # Controls the size of the arrowhead
            color=color,  # Color of the vector (blue)
            linewidth=2  # Line width for the vector
        )
        
    elif not plot_arrow and plot_line:
        ax.plot(origin, v, color=color)
        
    else:

        r = v + origin
        ax.scatter(r[0], r[1], r[2])
    
    ax.view_init(elev=elev, azim=azim)

    return ax


def bfield_from_thin_straight_wire(x, y, z, p1, p2, I, plot_wire=False, elev=45, azim=-45, ax=None):
    
    """
    Calculate the magnetic field generated by a thin, straight current-carrying wire at specified points in 3D space.

    Parameters
    ----------
    x, y, z : ndarray
        Arrays representing the x, y, and z coordinates of the points where the magnetic field is to be computed [m].
        
    p1 : array_like
        The 3D coordinates [x, y, z] of one end of the wire [m].
        
    p2 : array_like
        The 3D coordinates [x, y, z] of the other end of the wire [m].
        
    I : float
        The current flowing through the wire in Amperes [A].
        
    plot_wire : bool, optional
        If True, plots the wire geometry and the field points in 3D space. Default is False.
        
    elev : float, optional
        The elevation angle (in degrees) for the 3D plot. Default is 45 degrees.
        
    azim : float, optional
        The azimuth angle (in degrees) for the 3D plot. Default is -45 degrees.
        
    ax : matplotlib.axes._subplots.Axes3DSubplot, optional
        The axis object on which to plot the wire geometry. If None, a new figure and axis will be created. Default is None.

    Returns
    -------
    Bx, By, Bz : ndarray
        Arrays representing the magnetic field components along the x, y, and z axes at each specified point, with the same shape as the input coordinates [T].
        
    """
    
    # Convert input points to numpy arrays
    p1 = np.array(p1)     # three vector defining beginning of current element
    p2 = np.array(p2)     # three vector defining end of current element
    
    # Ensure the wire is specified by two distinct points
    assert np.linalg.norm(p2 - p1) > 0, 'Line must be specified by 2 distinct points'

    # Create a grid of observation points
    P = np.stack((x, y, z), axis=-1)  # Shape (Nx, Ny, Nz, 3)

    # Vector from p1 to p2 (the wire direction)
    L = p2 - p1
    Lhat = L / np.linalg.norm(L)  # Unit vector along the wire

    # Project P onto the line p1p2 to find the nearest point on the line to P
    tmin = np.dot(P - p1, Lhat)  # Shape (Nx, Ny, Nz)
    lmin = p1 + tmin[..., np.newaxis] * Lhat  # Shape (Nx, Ny, Nz, 3)

    # Calculate the vectors e1, e2, e3
    e1 = Lhat  # Shape (3,)
    e2 = P - lmin
    e2_norm = np.linalg.norm(e2, axis=-1, keepdims=True)
    e2 = e2 / e2_norm  # Normalize e2
    e3 = np.cross(e1, e2)  # Cross product to find e3, shape (Nx, Ny, Nz, 3)

    # Calculate x1 and x2
    x1 = np.dot(p1 - lmin, e1)  # Shape (Nx, Ny, Nz)
    x2 = np.dot(p2 - lmin, e1)  # Shape (Nx, Ny, Nz)

    # Distance R from the line to the point P
    R = e2_norm[..., 0]  # Shape (Nx, Ny, Nz)

    # Calculate the magnetic field magnitude B0
    B0 = (u0 * I / (4 * pi * R)) * (x2 / np.sqrt(x2**2 + R**2) - x1 / np.sqrt(x1**2 + R**2))  # Shape (Nx, Ny, Nz)

    # Final magnetic field vector at each point
    B = B0[..., np.newaxis] * e3  # Shape (Nx, Ny, Nz, 3)

    if plot_wire:
        ax = plot_3d_vector(p2-p1, p1, plot_arrow=True, color='k', elev=45, azim=-45, ax=ax)
        ax.set_xlabel('x (m)')
        ax.set_ylabel('y (m)')
        ax.set_zlabel('z (m)')

    return B[:,:,:,0], B[:,:,:,1], B[:,:,:,2]


def bfield_from_thin_rectangular_coil(X, Y, Z, a, b, y0, I, plot_wire=False, elev=45, azim=-45, ax=None):

    """
    Calculate the magnetic field generated by a thin, rectangular current-carrying coil at specified points in 3D space.

    Parameters
    ----------
    X, Y, Z : ndarray
        Arrays representing the x, y, and z coordinates of the points where the magnetic field is to be computed [m].
        
    a : float
        The horizontal size of the rectangular coil (length along the x-axis) [m].
        
    b : float
        The longitudinal size of the rectangular coil (length along the z-axis) [m].
        
    y0 : float
        The y-coordinate of the coil, representing the vertical position of the coil [m].
        
    I : float
        The current flowing through the rectangular coil in Amperes [A].
        
    plot_wire : bool, optional
        If True, plots the coil geometry and the field points in 3D space. Default is False.
        
    elev : float, optional
        The elevation angle (in degrees) for the 3D plot. Default is 45 degrees.
        
    azim : float, optional
        The azimuth angle (in degrees) for the 3D plot. Default is -45 degrees.
        
    ax : matplotlib.axes._subplots.Axes3DSubplot, optional
        The axis object on which to plot the coil geometry. If None, a new figure and axis will be created. Default is None.

    Returns
    -------
    Bx, By, Bz : ndarray
        Arrays representing the magnetic field components along the x, y, and z axes at each specified point, with the same shape as the input coordinates [T].
    """
    
    p1 = np.array([-a/2, y0, -b/2])
    p2 = np.array([+a/2, y0, -b/2])
    p3 = np.array([+a/2, y0, +b/2])
    p4 = np.array([-a/2, y0, +b/2])
    
    Bx1, By1, Bz1 = bfield_from_thin_straight_wire(X, Y, Z, p1, p2, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)

    if plot_wire:
        ax = plt.gca()
    
    Bx2, By2, Bz2 = bfield_from_thin_straight_wire(X, Y, Z, p2, p3, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)
    Bx3, By3, Bz3 = bfield_from_thin_straight_wire(X, Y, Z, p3, p4, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)
    Bx4, By4, Bz4 = bfield_from_thin_straight_wire(X, Y, Z, p4, p1, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)

    return (Bx1+Bx2+Bx3+Bx4, By1+By2+By3+By4, Bz1+Bz2+Bz3+Bz4)


def bfield_from_thin_rectangular_corrector(X, Y, Z, a, b, h, I, plot_wire=False, elev=45, azim=-45, ax=None):

    """
    Calculate the magnetic field generated by a thin, rectangular air-core corrector magnet at specified points in 3D space.

    Parameters
    ----------
    X, Y, Z : ndarray
        Arrays representing the x, y, and z coordinates of the points where the magnetic field is to be computed [m].
        
    a : float
        The horizontal size of the rectangular corrector (length along the x-axis) [m].
        
    b : float
        The longitudinal size of the rectangular corrector (length along the z-axis) [m].
        
    h : float
        The vertical separation between the two rectangular coils (distance along the y-axis) [m].
        
    I : float
        The current flowing through the rectangular corrector in Amperes [A].
        
    plot_wire : bool, optional
        If True, plots the coil geometry and the field points in 3D space. Default is False.
        
    elev : float, optional
        The elevation angle (in degrees) for the 3D plot. Default is 45 degrees.
        
    azim : float, optional
        The azimuth angle (in degrees) for the 3D plot. Default is -45 degrees.
        
    ax : matplotlib.axes._subplots.Axes3DSubplot, optional
        The axis object on which to plot the coil geometry. If None, a new figure and axis will be created. Default is None.

    Returns
    -------
    Bx, By, Bz : ndarray
        Arrays representing the magnetic field components along the x, y, and z axes at each specified point, with the same shape as the input coordinates [T].
    """    

    Bx1, By1, Bz1 = bfield_from_thin_rectangular_coil(X, Y, Z, a, b, -h/2, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)

    if plot_wire:
        ax = plt.gca()
    
    Bx2, By2, Bz2 = bfield_from_thin_rectangular_coil(X, Y, Z, a, b, +h/2, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)
    
    return (Bx1+Bx2, By1+By2, Bz1+Bz2)


def rotate_around_e3(theta):

    """
    Rotation matrix around z-axis

    Parameters:

    theta: float, [rad]
        Rotation angle.

    Returns:
    3D Rotation Matrix for rotation by theta [rad] around z-axis
    """
    
    C, S = np.cos(theta),np.sin(theta)

    return np.array( [[C, -S, 0],[+S, C, 0], [0,0,0]] )


def get_arc_vectors(h, R, theta, 
                    npts=100, 
                    arc_e3=np.array([0,0,1]) ):

    """
    Function to generate points of an arc with radius R in the plane y=h.
    The points subtend an angle of theta [rad] in the xz plane.

    Parameters:
    h: float, [m]
        height offset of the arc, defines the plane the arc lives in: y=h.
    R: float, [m]
        Radius of the arc.
    npts, int 
        Number of points to sample on the arc, arc is made of npts-1 line segments

    Returns:
        ndarray of size = (npts, 3) storing the points on the arc
    """

    phi = (np.pi - theta)/2

    arc_e1 = np.matmul(rotate_around_e3(phi), np.array([1,0,0]))

    assert np.isclose(np.dot(arc_e1, arc_e3), 0)
    
    arc_e2 = np.cross(arc_e3, arc_e1)

    ths = np.linspace(0, theta, npts)

    ps = np.zeros( (len(ths), 3) ) 

    for ii, th in enumerate(ths):
        ps[ii, :] = np.array([0,0,h])+ R*np.matmul(rotate_around_e3(th), arc_e1)

    return ps
    
        
def plot_arc_vectors(ps, color='k', elev=45, azim=-45, ax=None):

    for ii in range(ps.shape[0]-1):

        p1 = ps[ii,:]
        p2 = ps[ii+1,:]

        if ax is None:
            ax = plot_3d_vector(p2-p1, 
                                origin=p1, 
                                color='k', 
                                elev=elev, azim=azim, 
                                plot_arrow=True, plot_line=False)
        else:
            ax = plot_3d_vector(p2-p1, 
                                origin=p1, 
                                color='k', 
                                elev=elev, azim=azim, 
                                plot_arrow=True, plot_line=False, 
                                ax=ax)

    return ax
    

def bfield_from_thin_wire_arc(X, Y, Z, h, R, theta, npts=100, I=1, plot_wire=False, elev=45, azim=-45, ax=None):

    ps = get_arc_vectors(h, R, theta, npts=npts)

    Bx = np.zeros(X.shape)
    By = np.zeros(Y.shape)
    Bz = np.zeros(Z.shape)

    for ii in range(ps.shape[0]-1):

        p1 = ps[ii,:]
        p2 = ps[ii+1,:]

        if ii == 1 and plot_wire:
            ax = plt.gca()

        Bxii, Byii, Bzii = bfield_from_thin_straight_wire(X, Y, Z, p1, p2, I, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)

        Bx = Bx + Bxii
        By = By + Byii
        Bz = Bz + Bzii

    return Bx, By, Bz


def bfield_from_thin_saddle_coil(X, Y, Z, L, R, theta, I, npts=10, plot_wire=False, elev=45, azim=-45, ax=None):

    phi = (np.pi - theta)/2

    Bx = np.zeros(X.shape)
    By = np.zeros(Y.shape)
    Bz = np.zeros(Z.shape)

    BxA1, ByA1, BzA1 = bfield_from_thin_wire_arc(X, Y, Z, -L/2, R, +theta, npts=npts, I=I, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)

    if plot_wire:
        ax = plt.gca()
        
    BxA2, ByA2, BzA2 = bfield_from_thin_wire_arc(X, Y, Z, +L/2, R, -theta, npts=npts, I=I, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)

    Bx += BxA1 + BxA2
    By += ByA1 + ByA2
    Bz += BzA1 + BzA2

    # Straight section 1
    p11 = np.array([R*np.cos(phi), R*np.sin(phi), +L/2])
    p21 = np.array([R*np.cos(phi), R*np.sin(phi), -L/2])

    BxS1, ByS1, BzS1 = bfield_from_thin_straight_wire(X, Y, Z, p11, p21, I=I, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)

    # Straight section 2
    p12 = np.array([-R*np.cos(phi), R*np.sin(phi), -L/2])
    p22 = np.array([-R*np.cos(phi), R*np.sin(phi), +L/2])

    BxS2, ByS2, BzS2 = bfield_from_thin_straight_wire(X, Y, Z, p12, p22, I=I, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)

    Bx += BxS1 + BxS2
    By += ByS1 + ByS2
    Bz += BzS1 + BzS2

    return (Bx, By, Bz)


def bfield_from_thin_saddle_corrector(X, Y, Z, L, R, theta, I, npts=10, plot_wire=False, elev=45, azim=-45, ax=None):

    Bx1, By1, Bz1 = bfield_from_thin_saddle_coil(X, Y, Z, +L, +R, theta, I, npts=npts, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)

    if plot_wire:
        ax = plt.gca()
    Bx2, By2, Bz2 = bfield_from_thin_saddle_coil(X, Y, Z, -L, -R, theta, I, npts=npts, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)
    
    return Bx1+Bx2, By1+By2, Bz1+Bz2


def make_rectangular_dipole_corrector_fieldmesh(*,
                                                a=None, b=None, h=None, 
                                                current=1, 
                                                xmin=None, xmax=None, nx=101,
                                                ymin=None, ymax=None, ny=101,
                                                zmin=None, zmax=None, nz=101,
                                                plot_wire=False):

    """
    Generates a 3D magnetic field mesh for a rectangular dipole corrector magnet.

    Parameters
    ----------
    a : float, optional
        Horizontal size of the rectangular coil in the x direction [m]. Default is None.
        
    b : float, optional
        Longitudinal size of the rectangular coil in the z direction [m]. Default is None.
        
    h : float, optional
        Vertical distance between the rectangular coils in the y direction [m]. Default is None.
        
    current : float, optional
        The current (in Amperes) flowing through the rectangular dipole corrector. Default is 1 A.
        
    xmin : float, optional
        Minimum x-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    xmax : float, optional
        Maximum x-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    nx : int, optional
        Number of points along the x-axis of the mesh grid. Default is 101.
        
    ymin : float, optional
        Minimum y-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    ymax : float, optional
        Maximum y-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    ny : int, optional
        Number of points along the y-axis of the mesh grid. Default is 101.
        
    zmin : float, optional
        Minimum z-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    zmax : float, optional
        Maximum z-coordinate of the mesh grid in [m]. If None, a default value is chosen based on the coil geometry. Default is None.
        
    nz : int, optional
        Number of points along the z-axis of the mesh grid. Default is 101.
        
    plot_wire : bool, optional
        If True, plots the wire geometry of the rectangular dipole corrector. Useful for visualizing the coil shape. Default is False.

    Returns
    -------
    Bx, By, Bz : ndarray
        Arrays representing the magnetic field components along the x, y, and z axes at each point in the 3D mesh grid.
        
    x, y, z : ndarray
        Arrays representing the x, y, and z coordinates of the mesh grid.

    Notes
    -----
    - This function models the magnetic field of a rectangular dipole corrector based on specified coil parameters `a`, `b`, and `h`.
    - The `plot_wire` option enables a 3D visualization of the wire geometry for verification of the coil design.

    Examples
    --------
    Create a field mesh for a rectangular dipole corrector magnet:

    >>> FM = make_rectangular_dipole_corrector_fieldmesh(current=10,
    ...                                                  a=0.5, b=1.0, h=0.2,
    ...                                                  xmin=-1, xmax=1, nx=101,
    ...                                                  ymin=-1, ymax=1, ny=101,
    ...                                                  zmin=-1, zmax=1, nz=101)

    Plot the wire geometry for a rectangular dipole corrector magnet:

    >>> FM = make_rectangular_dipole_corrector_fieldmesh(current=10,
    ...                                                  a=0.5, b=1.0, h=0.2,
    ...                                                  xmin=-1, xmax=1, nx=101,
    ...                                                  ymin=-1, ymax=1, ny=101,
    ...                                                  zmin=-1, zmax=1, nz=101,
    ...                                                  plot_wire=True)
    """

    xs = np.linspace(xmin, xmax, nx)
    ys = np.linspace(ymin, ymax, ny)
    zs = np.linspace(zmin, zmax, nz)
    
    X, Y, Z = np.meshgrid(xs, ys, zs, indexing='ij')

    Bx, By, Bz = bfield_from_thin_rectangular_corrector(X, Y, Z, a, b, h, current, plot_wire=True)
    
    dx = np.diff(xs)[0]
    dy = np.diff(ys)[0]
    dz = np.diff(zs)[0]
    
    attrs = {}
    attrs['gridOriginOffset'] = (xs[0], ys[0], zs[0])
    attrs['gridSpacing'] = (dx, dy, dz)
    attrs['gridSize'] = Bx.shape
    attrs['eleAnchorPt'] = 'center'
    attrs['gridGeometry'] = 'rectangular'
    attrs['axisLabels'] = ('x', 'y', 'z')
    attrs['gridLowerBound'] = (0, 0, 0)
    attrs['harmonic'] = 0
    attrs['fundamentalFrequency'] = 0

    components = {}
    components['magneticField/x'] = Bx
    components['magneticField/y'] = By
    components['magneticField/z'] = Bz

    data = dict(attrs=attrs, components=components)

    return FieldMesh(data=data)


def make_saddle_dipole_corrector_fieldmesh(*,
                                           R=None, L=None, theta=None, 
                                           current=1, 
                                           xmin=None, xmax=None, nx=101,
                                           ymin=None, ymax=None, ny=101,
                                           zmin=None, zmax=None, nz=101, 
                                           npts=20, plot_wire=False):

    """
    Generates a 3D magnetic field mesh for a saddle dipole corrector based on specified coil geometry.

    Parameters
    ----------
    R : float, optional
        Radius of the saddle coil in meters. Defines the curvature of the coil. Default is None.
        
    L : float, optional
        Length of the saddle coil along the z-axis in meters. Default is None.
        
    theta : float, optional
        Opening angle of the saddle coil in radians. Determines how wide the coil opens. Default is None.
        
    current : float, optional
        The current (in Amperes) flowing through the saddle dipole corrector. Default is 1 A.
        
    xmin : float, optional
        Minimum x-coordinate of the mesh grid in meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    xmax : float, optional
        Maximum x-coordinate of the mesh grid in meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    nx : int, optional
        Number of points along the x-axis of the mesh grid. Default is 101.
        
    ymin : float, optional
        Minimum y-coordinate of the mesh grid in meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    ymax : float, optional
        Maximum y-coordinate of the mesh grid in meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    ny : int, optional
        Number of points along the y-axis of the mesh grid. Default is 101.
        
    zmin : float, optional
        Minimum z-coordinate of the mesh grid in meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    zmax : float, optional
        Maximum z-coordinate of the mesh grid meters. If None, a default value is chosen based on the coil geometry. Default is None.
        
    nz : int, optional
        Number of points along the z-axis of the mesh grid. Default is 101.
        
    npts : int, optional
        Number of discrete points used to model the saddle coil geometry. Default is 20.
        
    plot_wire : bool, optional
        If True, plots the wire geometry of the saddle coil. Useful for visualizing the coil shape. Default is False.

    Returns
    -------
    FM : FieldMesh Object
        Object representing the magnetic field components along the x, y, and z axes at each point in the 3D mesh grid.

    Notes
    -----
    - This function models the magnetic field of a saddle-shaped dipole corrector, using coil parameters `R`, `L`, and `theta`.
    - The `npts` parameter controls the discretization of the saddle coil in the numerical model.
    - If `plot_wire` is set to True, the wire geometry of the saddle dipole will be visualized.

    Examples
    --------
    Create a saddle dipole corrector field mesh:

    >>> FM = make_saddle_dipole_corrector_fieldmesh(current=5,
    ...                                             R=0.5, L=1.0, theta=np.pi/4,
    ...                                             xmin=-1, xmax=1, nx=101,
    ...                                             ymin=-1, ymax=1, ny=101,
    ...                                             zmin=-1, zmax=1, nz=101, 
    ...                                             npts=50)
    
    Plot the wire geometry of the saddle dipole corrector:

    >>> FM = make_saddle_dipole_corrector_fieldmesh(current=5,
    ...                                             R=0.5, L=1.0, theta=np.pi/4,
    ...                                             xmin=-1, xmax=1, nx=101,
    ...                                             ymin=-1, ymax=1, ny=101,
    ...                                             zmin=-1, zmax=1, nz=101, 
    ...                                             npts=50, plot_wire=True)
    """

    xs = np.linspace(xmin, xmax, nx)
    ys = np.linspace(ymin, ymax, ny)
    zs = np.linspace(zmin, zmax, nz)

    X, Y, Z = np.meshgrid(xs, ys, zs, indexing='ij')
    
    Bx, By, Bz = bfield_from_thin_saddle_corrector(X, Y, Z, L, R, theta, npts=npts, I=current, plot_wire=plot_wire)
    
    dx = np.diff(xs)[0]
    dy = np.diff(ys)[0]
    dz = np.diff(zs)[0]
    
    attrs = {}
    attrs['gridOriginOffset'] = (xs[0], ys[0], zs[0])
    attrs['gridSpacing'] = (dx, dy, dz)
    attrs['gridSize'] = Bx.shape
    attrs['eleAnchorPt'] = 'center'
    attrs['gridGeometry'] = 'rectangular'
    attrs['axisLabels'] = ('x', 'y', 'z')
    attrs['gridLowerBound'] = (0, 0, 0)
    attrs['harmonic'] = 0
    attrs['fundamentalFrequency'] = 0

    components = {}
    components['magneticField/x'] = Bx
    components['magneticField/y'] = By
    components['magneticField/z'] = Bz

    data = dict(attrs=attrs, components=components)

    return FieldMesh(data=data)


def make_dipole_corrector_fieldmesh(*,
                                    current=1,
                                    xmin=None, xmax=None, nx=101,
                                    ymin=None, ymax=None, ny=101,
                                    zmin=None, zmax=None, nz=101, 
                                    mode='rectangular',
                                    a=None, b=None, h=None,                   # Parameters for rectangular dipole corrector
                                    R=None, L=None, theta=None, npts=None,    # Parameters for saddle dipole corrector
                                    plot_wire=False):

    """
    Generates a 3D magnetic field mesh for a dipole corrector based on either a rectangular or saddle coil design.

    Parameters
    ----------
    current : float, optional
        The current (in Amperes) flowing through the dipole corrector. Default is 1 A.
        
    xmin : float, optional
        Minimum x-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    xmax : float, optional
        Maximum x-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    nx : int, optional
        Number of points along the x-axis of the mesh grid. Default is 101.
        
    ymin : float, optional
        Minimum y-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    ymax : float, optional
        Maximum y-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    ny : int, optional
        Number of points along the y-axis of the mesh grid. Default is 101.
        
    zmin : float, optional
        Minimum z-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    zmax : float, optional
        Maximum z-coordinate of the mesh grid in meters. If None, a default value is chosen based on the mode. Default is None.
        
    nz : int, optional
        Number of points along the z-axis of the mesh grid. Default is 101.
        
    mode : {'rectangular', 'saddle'}, optional
        The design of the dipole corrector to use. Can be either 'rectangular' or 'saddle'. Default is 'rectangular'.
        
    a : float, optional
        Length of the rectangular coil along the x-axis in meters. Only used in 'rectangular' mode. Default is None.
        
    b : float, optional
        Length of the rectangular coil along the z-axis in meters. Only used in 'rectangular' mode. Default is None.
        
    h : float, optional
        Vertical separation of rectangular coils along the y-axis in meters. Only used in 'rectangular' mode. Default is None.
        
    R : float, optional
        Radius of the saddle coil in meters. Only used in 'saddle' mode. Default is None.
        
    L : float, optional
        Length of the saddle coil along the z-axis in meters. Only used in 'saddle' mode. Default is None.
        
    theta : float, optional
        Opening angle of the saddle coil in radians. Only used in 'saddle' mode. Default is None.
        
    npts : int, optional
        Number of discrete points used to model the saddle coil. Only used in 'saddle' mode. Default is None.
        
    plot_wire : bool, optional
        If True, plots the wire geometry of the dipole corrector. Default is False.

    Returns
    -------
    FM : FieldMesh Object
        Class representing the magnetic field components along the x, y, and z axes at each point in the 3D mesh grid.
        

    Notes
    -----
    - In 'rectangular' mode, the magnetic field is computed based on a rectangular coil design with dimensions specified by
      `a`, `b`, and `h`.
    - In 'saddle' mode, the magnetic field is computed based on a saddle coil design, defined by the parameters `R`, `L`, `theta`, and `npts`.
    - If `plot_wire` is set to True, a plot of the wire geometry will be generated, useful for visualizing the coil shape.
    
    Examples
    --------
    Create a rectangular dipole corrector field mesh:
    
    >>> FM = make_dipole_corrector_fieldmesh(current=10, 
    ...                                      xmin=-1, xmax=1, nx=101,
    ...                                      ymin=-1, ymax=1, ny=101,
    ...                                      zmin=-1, zmax=1, nz=101,
    ...                                      mode='rectangular', 
    ...                                      a=0.5, b=0.5, h=0.5)
    
    Create a saddle dipole corrector field mesh:
    
    >>> FM = make_dipole_corrector_fieldmesh(current=10, 
                                             xmin=-1, xmax=1, nx=101,
    ...                                      ymin=-1, ymax=1, ny=101,
    ...                                      zmin=-1, zmax=1, nz=101,
    ...                                      mode='saddle', 
    ...                                      R=0.5, L=1.0, theta=np.pi/4, npts=100)
    """

    

    if mode == 'rectangular':
        if a is None or b is None or h is None:
            raise ValueError("Parameters 'a', 'b', and 'h' must be provided for rectangular mode.")

        f = 0.99
        
        if xmin is None:
            xmin = -f*a

        if ymin is None: 
            ymin = -f*h/2

        if zmin is None:
            zmin = -5*b

        if xmax is None:
            xmax = +f*a

        if ymax is None: 
            ymax = +f*h/2

        if zmax is None:
            zmax = +5*b
            
        # Call the rectangular dipole corrector function
        return make_rectangular_dipole_corrector_fieldmesh(a=a, b=b, h=h, current=current, 
                                                           xmin=xmin, xmax=xmax, nx=nx,
                                                           ymin=ymin, ymax=ymax, ny=ny,
                                                           zmin=zmin, zmax=zmax, nz=nz,
                                                           plot_wire=plot_wire)

    elif mode == 'saddle':
        
        if xmin is None:
            xmin = -R

        if ymin is None: 
            ymin = -R

        if zmin is None:
            zmin = -5*L/2

        if xmax is None:
            xmax = +R

        if ymax is None: 
            ymax = +R

        if zmax is None:
            zmax = +5*L/2
        
        # Check that necessary parameters are provided
        if R is None or L is None or theta is None:
            raise ValueError("Parameters 'R', 'L', and 'theta' must be provided for saddle mode.")
        # Call the saddle dipole corrector function
        return make_saddle_dipole_corrector_fieldmesh(R=R, L=L, theta=theta, current=current, 
                                                      xmin=xmin, xmax=xmax, nx=nx,
                                                      ymin=ymin, ymax=ymax, ny=ny,
                                                      zmin=zmin, zmax=zmax, nz=nz,
                                                      npts=npts, plot_wire=plot_wire)
    
    else:
        raise ValueError("Invalid mode. Choose either 'rectangular' or 'saddle'.")
    
    

